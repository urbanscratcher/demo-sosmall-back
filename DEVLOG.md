# 프로젝트 시작 동기

- 예전에 학원에서 스프링 프레임워크를 사용해 만들었던 이 프로젝트를 다시 보니 다듬고 싶어서 뜯어 보게 됐다. 이전에는 spring, mybatis, oracle mysql, html, css, js, jquery, bootstrap를 사용했다. 그런데 내가 ER을 너무 복잡하게 그리는 바람에 완성도 있게 끝내지 못했다. 쇼핑몰은 복잡한 메커니즘이 많아 프론트나 백이나 좋은 공부가 될 수 있다고 생각했고, 한 번쯤은 데모 프로젝트로 완성도 있게 만들어 보고 싶었다.

# 1일차 - 개발 환경 설정

- IDE는 인텔리제이가 정말 좋은데 VS코드에 너무 익숙해져서 인텔리제이 대신 사용하게 되었다. 확장팩 몇 개를 설치하니 그럭저럭 쓸만하다. 코드 정리 잘되고 잘 돌아가기만 하면 되니까. 코드 변경 후 컴파일 될 때 조금 버벅거리는 느낌.

- JS/TS를 사용하다 오랜만에 자바를 마주한 소감. 자바는 정말 verbose하다. JS/TS에서 익숙해진 람다식을 써볼까 하는데 상대적으로 덕지 덕지... 쳐야할 게 너무 많지만 그만큼 안정감이 있기도 하다. 무겁고 강한 도끼전사나 거포 타자 같음.

- NestJS만 사용하다가 오랜만에 스프링을 마주한 소감. 스프링의 추상화 된 개념들은 봐도 봐도 난해하다. 그래도 오래된 프레임워크이지 만큼 웬만한 에러 메시지나 알고 싶은 것들은 다 검색이 되고 자료도 방대하다. NodeJS나 NestJS는 스택오버플로우를 전부 읽어도 솔루션이 없는 경우가 많은데 스프링은 거의 다 해결되는 편이다. 그리고 디버깅 메시지만 읽어도 대충 어디서 에러가 났는지 감이 잡힌다(OOP의 위력인가?) 다만 버전 같은 걸 엄청 타서 설정을 정말 잘해야 한다.

- 일단 스프링 부트랑 마이바티스만 연결하고 실행을 확인했다. 스프링 프로젝트는 실행만 잘 되면 거의 절반은 오는 듯.

# 2일차 - ERD 설계

- 프로젝트 파일을 뜯어 봤더니 쓸만한 건 요구사항 정의서와 ER 정도라 아예 새로 시작했다. 그런 걸 보면 역시 기초 공사에 해당하는 기능 정의와 RDB가 정말 중요하다는 것을 새삼 깨닫는다.

- 하면 할 수록 고려할 게 많아서 제약사항을 두었다. 범위를 한정시키는 것은 프로젝트 성공에 정말 중요하다.

- 쇼핑몰은 생각보다 백오피스단 로직이 복잡하다. 예전에 11번가 등 여러 쇼핑몰에 상품 올리는 알바를 한 적이 있는데 썸네일도 하나하나 넣고, 브랜드명이나 코드, 각종 옵션들, 옵션에 딸린 가격 등등 등록할 게 엄청 많았던 걸로 기억한다. 거기다 배송, 반품, 교환 정책들, 결제 모듈도 시스템에 넣는다고 생각하면... 이번 프로젝트는 풀스택으로 짧은 기간 개발하니 만큼 핵심 기능에만 집중하려 한다.

# 3일차 - 엔티티 작성 (w/ JPA)

- 내 첫 ORM 툴은 NestJS의 TypeORM이었는데 JPA를 사용해보니 나름 신세계다. 가장 마음에 드는 건 카멜케이스나 파스칼케이스로 작성된 필드명이 저절로 스네이크 케이스로 변환되는 것. 이 작은 편의가 얼마나 개발 경험을 좋게 만드는지.

- TypeORM은 익숙해지긴 했지만 사실 사용법이 그리 직관적이진 않다. 그러니까 주요 기능은 괜찮은데 케이스 컨벤션 변환도 그렇고 사소한 데서 좀 해줘야 할 게 많달까. 그러다가 뭐 결국 쿼리빌더 행... 스프링 진영도 JOOQ 같은 타입 세이프한 툴이 있던데 이거랑 비슷하려나? ORM을 애매하게 쓸거면 그냥 SQL 쓰는 게 마음이 가장 편한 것 같다.

- 그래서 설치해 둔 게 마이바티스인데 xml을 다시 보니까 이렇게 귀찮게 쓰고 있었나 어질어질하다. ORM이 개발 편의성이나 생산성이 훨씬 더 낫다는 걸 새삼 깨닫는다. 이미 템플릿화 해둔 NestJS에서는 엔티티 작성만 하면 거의 끝인데ㅠㅠ 복잡한 조인문은 마이바티스를 사용할 계획이다.

- 엔티티 관계(단방향/양방향, 1:N, N:1, 1:1)를 생각하면서 ERD를 좀 더 수정했다. 개념적으로 가까운 것끼리 묶고, 다른 것은 최대한 분리하려고 FK 대신 인덱싱을 추가했다. 회원, 상품, 주문서, 후기, 장바구니, 관심상품의 6개 엔티티로 깔끔하게 정리됐다.

- 요즘 디자인 강의를 듣는 도중. 웹 디자인 법칙에도 Vertical hierarchy를 구현하기 위해 유사한 정보끼리는 여백을 적게 주고, 다른 정보는 여백을 많이 줘서 그룹핑을 해줘야 한다는데 응집도를 높이고, 결합도를 낮추는 소프트웨어 공학과 맞닿아 있지 않나 싶다. 나는 어렸을 때 흐트러진 걸 분류하는 일을 하면 제일 재밌게 잘 할 수 있을거라고 생각한 적이 있다. 개발은 분명 그런 요소가 있어서 재밌게 다가오는 것 같다.

# 4일차 - CRUD 작성(1)

- 역시 TypeORM과 씨름한 것처럼 JPA와도 씨름해야 했다. 특히 cascading이나 lazy, eager 옵션은 적용해도 될 때가 있고 안 될 때가 있고... 예제들과 다른 상황들이 많아 생각대로 작동하지 않는 경우가 많다. 그냥 레포지토리에 쿼리만 늘어날 것 같기도 하고ㅠㅠ 코드를 깔끔하고 일관되게 짜고 싶은데 ORM 라이브러리들은 그런 걸 당최 허락해주지 않는다. 이건 그룹핑 같은 게 되는 TypeORM이 좀 더 나은 것 같다.

- 성능 튜닝도 함께 한 시간(?)이 있는 만큼 TypeORM은 완전 자유자재인데, JPA도 익히면서 하려니 시간이 너무 많이 들어서. 개념을 이해하고 적용해도 뭔가 생각대로 안된다; 결국 약간의 미세한 성능 이슈는 포기했다(조인을 할 때와 안 할 때를 구분해서 콜을 한다던가). 그냥 데이터 모델링 할 때 분리를 잘 해놓은 것 같아서 그런 단위로 생각해야 할 듯.

- API 관점과 데이터 모델의 관점이 다른데, 프로그램 짤 때 이걸 잘 구분해야 한다.

- 처음에는 폴더 구조도 NestJS 처럼 엔티티 기반으로 했다가 보일러 플레이트 코드들이 너무 많아서 복붙하려고 결국 레이어 별로 구성했다.

- Optional 너무 싫다... TS의 ? 체인, NestJS의 MappedTypes, 커스텀하기 좋게 짜놓은 유틸 등등이 너무너무너무 그립다... DTO나 생성자 같은 보일러 플레이트 코드들 치다가 로직을 까먹는데 개발 경험은 NestJS가 훨씬 나은 것 같다. 후... 이게 이렇게나 오래 걸릴 일이냐고;;; 새삼 내가 NestJS로부터 생산성을 뽑기 위해 최대한의 것을 다 했구나 하는 생각이 든다. 아무래도 유효성 체크는 중요한 것만 하거나 프론트로 넘겨야 할 듯하다.

- 디버깅은 정말 만족!!!! 어디서 뭐가 잘못 됐는지 굉장히 명확하게 나온다.

# 5~7일차 - CRUD 작성(2)

- 점점 복잡한 쿼리의 세계로 들어가고 있다. N+1 문제, Cartesian Product 문제 등을 해결하려 하는데 페이지네이션, 정렬, 쿼리 등 여러 조건을 고려해야 하기 때문에 역시 list는 마이바티스로 작성하는 게 정신 건강에 좋을 것 같다. 특히 여러 개의 OneToMany를 fetch join 하기 위해서는 batch size나 Set으로 정의하기 등 몇 가지 해결책이 있었지만, 근본적인 해결은 못하는 것 같았다. 이전에 TypeORM도 N+1 문제를 해결하기 위해서 쿼리 빌더 + 제네릭스를 사용해서 최대한 동적으로 sql을 생성할 수 있도록 템플릿화 해 놓은 적이 있다. 시간이 엄청 걸렸던. Cartesian Product 문제는 생각도 못했는데. 역시 join이 복잡해지면 검색 최적화를 고려하며 raw sql로 개발하는 게 나은 것 같다. list는 검색 속도가 생명이잖아요,,

- member와 admin이 보는 데이터도 차이가 나는데 역시 admin은 배제하기로 했다. 늘 백오피스를 생각하면서 개발하다보니 죽 마음에 걸리지만...

- 이래서 MSA 개념을 차용하는 건가 싶다. 엔티티 별로 완전히 분리한다면 콜 횟수만 많아질 뿐 내부 개발은 훨씬 편리해진다. jpa 기본 repository 메서드만 사용해도 될 정도로. 그러니까 네트워크상 콜 횟수만 관리하면 되고 이런 것 때문에 MSA 구조는 상당 부분 인프라에 의존하게 될 것이다. 애로사항이 있다면 엔티티간의 교집합을 어떻게 처리하느냐인데 특히 트랜잭션이 걸린다. API 콜 간 트랜잭션을 잡으려면 또 기술적인 부분이 필요하고(여기까지는 가지 말자고 해서 많은 공부를 하진 못했다). member, admin 같은 owner의 경우에도 auth 서버를 분리해 붙였다 뗐다 할 수 있는 등 개발 방향이 유연해진다. 뭉탱이로 붙여서 개발하느냐, MSA로 쪼개느냐... 역시 트레이드오프가 있는 것 같다.

- read와 write 간에 행위가 다른데 이걸 고려하는 것도 중요한 것 같다. read는 위계 구조로 잘 보여주는 게 데이터 교환 cost 측면에서 더 좋고, write는 트랜잭션 잡기가 쉽다. 하지만 이러면 엔티티들이 위계 구조에 의존하게 돼서 설계가 유연해지지는 못한다. MSA에서는 순수 엔티티를 정의하고, 엔티티를 묶는 코어 단이 있고 이런식으로 레이어를 나눠 동적인 설계가 가능하도록 한다.

- 하지만 이 모든 건 일이 너무 많다! 각 레이어 별 어떻게 통신할지도 정의해야 하고, 레이어 간 콜 수도 많아질 테고. 그런거 고려하면 또 rpc 같은 걸 건드릴 텐데 뭔가 작은 규모에서는 배보다 배꼽이 커진다. 일단 이 프로젝트 사이즈에 맞춰 제한 하기로 했다. 욕심이 나긴 하지만, 빨리 끝내야 하기도 하고, 추후 프로젝트를 수정하다 보면 변형이 쉬운 설계에 대한 인사이트도 생길 것 같아서이다.

- 그래도 나름 자유롭게 이것 저것 해보면서 알아가는 재미가 있다. jpa 써보니까 TypeORM과의 유사성을 더 느끼기도 하고 해서 역시 근본 개념이 중요하구나 다시 깨닫는다.
