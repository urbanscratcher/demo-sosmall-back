# 프로젝트 시작 동기

- 예전에 학원에서 스프링 프레임워크를 사용해 만들었던 이 프로젝트를 다시 보니 다듬고 싶어서 뜯어 보게 됐다. 이전에는 spring, mybatis, oracle mysql, html, css, js, jquery, bootstrap를 사용했다. 그런데 내가 ER을 너무 복잡하게 그리는 바람에 완성도 있게 끝내지 못했다. 쇼핑몰은 복잡한 메커니즘이 많아 프론트나 백이나 복잡하기 때문에 좋은 공부가 될 수 있다고 생각했고, 한 번쯤은 데모 프로젝트로 완성도 있게 만들어 보고 싶었다.

# 1일차 - 개발 환경 설정

- IDE는 인텔리제이가 정말 좋은데 VS코드에 너무 익숙해져서 인텔리제이 대신 사용하게 되었다. 확장팩 몇 개를 설치하니 그럭저럭 쓸만하다. 코드 정리 잘되고 잘 돌아가기만 하면 되니까. 코드 변경 후 컴파일 될 때 조금 버벅거리는 느낌.

- JS/TS를 사용하다 오랜만에 자바를 마주한 소감. 자바는 정말 verbose하다. JS/TS에서 익숙해진 람다식을 써볼까 하는데 상대적으로 덕지 덕지... 쳐야할 게 너무 많지만 그만큼 안정감이 있기도 하다. 무겁고 강한 도끼전사나 거포 타자 같음.

- NestJS만 사용하다가 오랜만에 스프링을 마주한 소감. 스프링의 추상화 된 개념들은 봐도 봐도 난해하다. 그래도 오래된 프레임워크이지 만큼 웬만한 에러 메시지나 알고 싶은 것들은 다 검색이 되고 자료도 방대하다. NodeJS나 NestJS는 스택오버플로우를 전부 읽어도 솔루션이 없는 경우가 많은데 스프링은 거의 다 해결되는 편이다. 그리고 디버깅 메시지만 읽어도 대충 어디서 에러가 났는지 감이 잡힌다(OOP의 위력인가?) 다만 버전 같은 걸 엄청 타서 설정을 정말 잘해야 한다.

- 일단 스프링 부트랑 마이바티스만 연결하고 실행을 확인했다. 스프링 프로젝트는 실행만 잘 되면 거의 절반은 오는 듯?

# 2일차 - ERD 설계

- 프로젝트 파일을 뜯어 봤더니 쓸만한 건 요구사항 정의서와 ER 정도라 아예 새로 시작했다. 그런 걸 보면 역시 기초 공사에 해당하는 기능 정의와 RDB가 정말 중요하다는 것을 새삼 깨닫는다.

- 하면 할 수록 고려할 게 많아서 제약사항을 두었다. 범위를 한정시키는 것은 프로젝트 성공에 정말 중요하다.

- 쇼핑몰은 생각보다 백오피스단 로직이 복잡하다. 예전에 11번가 등 여러 쇼핑몰에 상품 올리는 알바를 한 적이 있는데 썸네일도 하나하나 넣고, 브랜드명이나 코드, 각종 옵션들, 옵션에 딸린 가격 등등 등록할 게 엄청 많았던 걸로 기억한다. 거기다 배송, 반품, 교환 정책들, 결제 모듈도 시스템에 넣는다고 생각하면... 이번 프로젝트는 풀스택으로 짧은 기간 개발하니 만큼 핵심 기능에만 집중하려 한다.

# 3일차 - 엔티티 작성 (w/ JPA)

- 내 첫 ORM 툴은 NestJS의 TypeORM이었는데 JPA를 사용해보니 나름 신세계다. 가장 마음에 드는 건 카멜케이스나 파스칼케이스로 작성된 필드명이 저절로 스네이크 케이스로 변환되는 것. 이 작은 편의가 얼마나 개발 경험을 좋게 만드는지.

- TypeORM은 익숙해지긴 했지만 사실 사용법이 그리 직관적이진 않다. 그러니까 주요 기능은 괜찮은데 케이스 컨벤션 변환도 그렇고 사소한 데서 좀 해줘야 할 게 많달까. 그러다가 뭐 결국 쿼리빌더 행... 스프링 진영도 JOOQ 같은 타입 세이프한 툴이 있던데 이거랑 비슷하려나? ORM을 애매하게 쓸거면 그냥 SQL 쓰는 게 마음이 가장 편한 것 같다.

- 그래서 설치해 둔 게 마이바티스인데 xml을 다시 보니까 이렇게 귀찮게 쓰고 있었나 어질어질하다. ORM이 개발 편의성이나 생산성이 훨씬 더 낫다는 걸 새삼 깨닫는다. 이미 템플릿화 해둔 NestJS에서는 엔티티 작성만 하면 거의 끝인데ㅠㅠ 복잡한 조인문은 마이바티스를 사용할 계획이다.

- 엔티티 관계(단방향/양방향, 1:N, N:1, 1:1)를 생각하면서 ERD를 좀 더 수정했다. 개념적으로 가까운 것끼리 묶고, 다른 것은 최대한 분리하려고 FK 대신 인덱싱을 추가했다. 회원, 상품, 주문서, 후기, 장바구니, 관심상품의 6개 엔티티로 깔끔하게 정리됐다.

- 요즘 디자인 강의를 듣는 도중. 웹 디자인 법칙에도 Vertical hierarchy를 구현하기 위해 유사한 정보끼리는 여백을 적게 주고, 다른 정보는 여백을 많이 줘서 그룹핑을 해줘야 한다는데 응집도를 높이고, 결합도를 낮추는 소프트웨어 공학과 맞닿아 있지 않나 싶다. 나는 어렸을 때 흐트러진 걸 분류하는 일을 하면 제일 재밌게 잘 할 수 있을거라고 생각한 적이 있다. 개발은 분명 그런 요소가 있어서 재밌게 다가오는 것 같다.

# 4일차 - CRUD 작성(1)

- 역시 TypeORM과 씨름한 것처럼 JPA와도 씨름해야 했다. 특히 cascading이나 lazy, eager 옵션은 적용해도 될 때가 있고 안 될 때가 있고... 예제들과 다른 상황들이 많아 생각대로 작동하지 않는 경우가 많다. 그냥 레포지토리에 쿼리만 늘어날 것 같기도 하고ㅠㅠ 코드를 깔끔하고 일관되게 짜고 싶은데 ORM 라이브러리들은 그런 걸 당최 허락해주지 않는다. 이건 그룹핑 같은 게 되는 TypeORM이 좀 더 나은 것 같다.

- 성능 튜닝도 함께 한 시간(?)이 있는 만큼 TypeORM은 완전 자유자재인데, JPA도 익히면서 하려니 시간이 너무 많이 들어서. 개념을 이해하고 적용해도 뭔가 생각대로 안된다; 결국 약간의 미세한 성능 이슈는 포기했다(조인을 할 때와 안 할 때를 구분해서 콜을 한다던가). 그냥 데이터 모델링 할 때 분리를 잘 해놓은 것 같아서 그런 단위로 생각해야 할 듯.

- API 관점과 데이터 모델의 관점이 다른데, 프로그램 짤 때 이걸 잘 구분해야 한다.

- 처음에는 폴더 구조도 NestJS 처럼 엔티티 기반으로 했다가 보일러 플레이트 코드들이 너무 많아서 복붙하려고 결국 레이어 별로 구성했다.

- Optional 너무 싫다... TS의 삼항연산자와 ? 체인, NestJS의 MappedTypes, 커스텀하기 좋게 짜놓은 유틸 등등이 너무너무너무 그립다... DTO나 생성자 같은 보일러 플레이트 코드들 치다가 로직을 까먹는데 개발 경험은 NestJS가 훨씬 나은 것 같다. 후... 이게 이렇게나 오래 걸릴 일이냐고;;; 새삼 내가 NestJS로부터 생산성을 뽑기 위해 최대한의 것을 다 했구나 하는 생각이 든다. 아무래도 유효성 체크는 중요한 것만 하거나 프론트로 넘겨야 할 듯하다.

- 디버깅은 정말 만족!!!! 어디서 뭐가 잘못 됐는지 굉장히 명확하게 나온다.

# 5일차 - CRUD 작성(2)
